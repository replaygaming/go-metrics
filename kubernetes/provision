#!/usr/bin/env ruby

require "erb"
require "open3"
require "optparse"

options = {
  environment: "staging"
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: provision [options] IMAGE_TAG"

  opts.on("-e ENVIRONMENT", "--environment ENVIRONMENT", String, "Environment to provision. Defaults to 'staging'") do |env|
    options[:environment] = env
  end

  opts.on("-t NAME", "--topic_name NAME", String, "Topic name to use. Defaults to sane defaults depending on environment") do |topic_name|
    options[:topic_name] = topic_name
  end

  opts.on("-s NAME", "--subscription_name NAME", String, "Subscription name to use. Defaults to sane defaults depending on environment") do |subscription_name|
    options[:subscription_name] = subscription_name
  end

  opts.on("-n", "--dry-run", "Don't actually change anything, just print out generated deployment/service") do
    options[:dry_run] = true
  end
end
parser.parse!

class Provision
  def initialize(options, tag)
    @options = options
    @tag = tag
  end

  def environment
    @options[:environment]
  end

  def metrics_provider
    @options[:metrics_provider]
  end

  def tag
    @tag
  end

  def call
    ensure_secrets
    ensure_deployment
    if @options[:dry_run]
      puts
      puts "Nothing changed since dry run mode was used"
    else
      puts "Metrics provisioned successfully for environment '#{environment}'"
    end
  end

  def ensure_secrets
    ensure_pubsub
    ensure_metrics
  end

  def ensure_pubsub
    return if Kernel.system(*%W[kubectl get secret/pubsub -o name], err: :out, out: "/dev/null")

    abort "PubSub secrets are not configured. Make sure you have them provisioned from the infrastructure repository."
  end

  def ensure_metrics
    return if Kernel.system(*%W[kubectl get secret/metrics -o name], err: :out, out: "/dev/null")

    abort "Metrics secrets are not configured. Make sure you have them provisioned from the create_secrets script."
  end

  def ensure_deployment
    deployment_file = File.join(File.expand_path("..", __FILE__), "deployment.yaml.erb")
    resource = ERB.new(File.read(deployment_file)).result(binding)
    if @options[:dry_run]
      puts
      puts resource
      return
    end
    kube_apply(resource) || abort("Error applying deployment")
  end

  def topic_name
    return @options[:topic_name] if @options[:topic_name]

    case environment
    when "staging"
      "metrics-staging"
    when "production"
      "metrics"
    else
      abort("Don't know what topic name to use for this environment. Please provide one. See --help for more information")
    end
  end

  def subscription_name
    return @options[:subscription_name] if @options[:subscription_name]

    case environment
    when "staging"
      "metrics_workers_staging"
    when "production"
      "metrics_workers"
    else
      abort("Don't know what subscription name to use for this environment. Please provide one. See --help for more information")
    end
  end

  def kube_apply(resource)
    Open3.popen2e("kubectl apply --record=true -f -") do |stdin, out_err, wait_thr|
      stdin.write resource
      stdin.close
      output = out_err.read
      if wait_thr.value.success?
        true
      else
        puts output
        false
      end
    end
  end
end

tag = ARGV[0]
abort(parser.help) if tag.nil? || tag == ""

Provision.new(options, tag).call
